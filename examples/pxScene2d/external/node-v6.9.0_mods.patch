diff --git b/examples/pxScene2d/external/libnode-v6.9.0/buildNode.sh a/examples/pxScene2d/external/libnode-v6.9.0/buildNode.sh
new file mode 100755
index 0000000..4991935
--- /dev/null
+++ a/examples/pxScene2d/external/libnode-v6.9.0/buildNode.sh
@@ -0,0 +1,4 @@
+./configure --shared
+make -j
+ln -sf libnode.so.48 out/Release/obj.target/libnode.so
+ln -sf libnode.48.dylib out/Release/libnode.dylib
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/deps/uv/src/unix/async.c a/examples/pxScene2d/external/libnode-v6.9.0/deps/uv/src/unix/async.c
index 393cdeb..4dcf0b3 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/deps/uv/src/unix/async.c
+++ a/examples/pxScene2d/external/libnode-v6.9.0/deps/uv/src/unix/async.c
@@ -131,7 +131,9 @@ static void uv__async_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
   wa = container_of(w, struct uv__async, io_watcher);
 
 #if defined(__linux__)
-  if (wa->wfd == -1) {
+// MODIFIED CODE BEGIN
+  if (wa->wfd == -1 && n != 0) {
+// MODIFIED CODE END
     uint64_t val;
     assert(n == sizeof(val));
     memcpy(&val, buf, sizeof(val));  /* Avoid alignment issues. */
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/deps/uv/src/unix/core.c a/examples/pxScene2d/external/libnode-v6.9.0/deps/uv/src/unix/core.c
index cdcd0b5..b0f9c52 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/deps/uv/src/unix/core.c
+++ a/examples/pxScene2d/external/libnode-v6.9.0/deps/uv/src/unix/core.c
@@ -711,9 +711,14 @@ void uv_disable_stdio_inheritance(void) {
   /* Set the CLOEXEC flag on all open descriptors. Unconditionally try the
    * first 16 file descriptors. After that, bail out after the first error.
    */
-  for (fd = 0; ; fd++)
+  /*MODIFIED CODE BEGIN*/
+  //for (fd = 0; ; fd++)
+  for (fd = 3; ; fd++)
+  {
     if (uv__cloexec(fd, 1) && fd > 15)
       break;
+  }
+  /*MODIFIED CODE END*/
 }
 
 
@@ -986,6 +991,9 @@ int uv__open_cloexec(const char* path, int flags) {
 
 int uv__dup2_cloexec(int oldfd, int newfd) {
   int r;
+  /*MODIFIED CODE BEGIN*/
+  int flags = 0;
+  /*MODIFIED CODE END*/
 #if defined(__FreeBSD__) && __FreeBSD__ >= 10
   r = dup3(oldfd, newfd, O_CLOEXEC);
   if (r == -1)
@@ -1001,9 +1009,23 @@ int uv__dup2_cloexec(int oldfd, int newfd) {
 #elif defined(__linux__)
   static int no_dup3;
   if (!no_dup3) {
+    /*MODIFIED CODE BEGIN*/
+    //do
+    //  r = uv__dup3(oldfd, newfd, UV__O_CLOEXEC);
+    //while (r == -1 && errno == EBUSY);
     do
-      r = uv__dup3(oldfd, newfd, UV__O_CLOEXEC);
-    while (r == -1 && errno == EBUSY);
+    {
+      if (newfd >=0  && newfd <= 2)
+      {
+        flags = 0;
+      }
+      else
+      {
+        flags = UV__O_CLOEXEC;
+      }
+      r = uv__dup3(oldfd, newfd, flags);
+    }while (r == -1 && (errno == EINTR || errno == EBUSY));
+    /*MODIFIED CODE END*/
     if (r != -1)
       return r;
     if (errno != ENOSYS)
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/debug/debug-evaluate.cc a/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/debug/debug-evaluate.cc
index dae1348..70c1ec4 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/debug/debug-evaluate.cc
+++ a/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/debug/debug-evaluate.cc
@@ -29,9 +29,13 @@ MaybeHandle<Object> DebugEvaluate::Global(
   // Enter the top context from before the debugger was invoked.
   SaveContext save(isolate);
   SaveContext* top = &save;
+/* MODIFIED CODE BEGIN */
+/*
   while (top != NULL && IsDebugContext(isolate, *top->context())) {
     top = top->prev();
   }
+*/
+/* MODIFIED CODE END */
   if (top != NULL) isolate->set_context(*top->context());
 
   // Get the native context now set to the top context from before the
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/isolate.cc a/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/isolate.cc
index c9f0111..838b929 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/isolate.cc
+++ a/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/isolate.cc
@@ -1017,7 +1017,13 @@ Object* Isolate::Throw(Object* exception, MessageLocation* location) {
 
   HandleScope scope(this);
   Handle<Object> exception_handle(exception, this);
-
+  /* MODIFIED CODE BEGIN */
+  char const* stack_on_exception_enabled = getenv("DUMP_STACK_ON_EXCEPTION");
+  if (stack_on_exception_enabled && (strcmp(stack_on_exception_enabled,"1") == 0))
+  {
+    PrintCurrentStackTrace(stderr);
+  }
+  /* MODIFIED CODE END */
   // Determine whether a message needs to be created for the given exception
   // depending on the following criteria:
   // 1) External v8::TryCatch missing: Always create a message because any
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/js/promise.js a/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/js/promise.js
index 201a06c..7200779 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/js/promise.js
+++ a/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/js/promise.js
@@ -285,8 +285,14 @@ function PromiseThen(onResolve, onReject) {
   var deferred = NewPromiseCapability(constructor);
   switch (status) {
     case 0:  // Pending
-      GET_PRIVATE(this, promiseOnResolveSymbol).push(onResolve, deferred);
-      GET_PRIVATE(this, promiseOnRejectSymbol).push(onReject, deferred);
+      /* MODIFIED CODE BEGIN */
+      var resolveSym = GET_PRIVATE(this, promiseOnResolveSymbol);
+      if (!IS_UNDEFINED(resolveSym))
+        resolveSym.push(onResolve, deferred);
+      var rejectSym = GET_PRIVATE(this, promiseOnRejectSymbol);
+      if (!IS_UNDEFINED(rejectSym))
+        rejectSym.push(onReject, deferred);
+      /* MODIFIED CODE END */
       break;
     case +1:  // Resolved
       PromiseEnqueue(GET_PRIVATE(this, promiseValueSymbol),
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/runtime/runtime-debug.cc a/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/runtime/runtime-debug.cc
index 3263a89..a6a7b47 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/runtime/runtime-debug.cc
+++ a/examples/pxScene2d/external/libnode-v6.9.0/deps/v8/src/runtime/runtime-debug.cc
@@ -102,9 +102,22 @@ static Handle<Object> DebugGetProperty(LookupIterator* it,
         // Ignore access checks.
         break;
       case LookupIterator::INTEGER_INDEXED_EXOTIC:
-      case LookupIterator::INTERCEPTOR:
+/* MODIFIED CODE BEGIN */
       case LookupIterator::JSPROXY:
         return it->isolate()->factory()->undefined_value();
+      case LookupIterator::INTERCEPTOR:
+      {
+        bool ret;
+        MaybeHandle<Object> maybe_result = JSObject::GetPropertyWithInterceptor(it,&ret);
+        Handle<Object> result;
+        if (!maybe_result.ToHandle(&result)) {
+          result = handle(it->isolate()->pending_exception(), it->isolate());
+          it->isolate()->clear_pending_exception();
+          if (has_caught != NULL) *has_caught = true;
+        }
+        return result;
+      }
+/* MODIFIED CODE END */
       case LookupIterator::ACCESSOR: {
         Handle<Object> accessors = it->GetAccessors();
         if (!accessors->IsAccessorInfo()) {
@@ -356,9 +369,9 @@ RUNTIME_FUNCTION(Runtime_DebugGetPropertyDetails) {
       isolate->factory()->NewFixedArray(has_js_accessors ? 6 : 3);
   details->set(0, *value);
   // TODO(verwaest): Get rid of this random way of handling interceptors.
-  PropertyDetails d = it.state() == LookupIterator::INTERCEPTOR
-                          ? PropertyDetails::Empty()
-                          : it.property_details();
+/* MODIFIED CODE BEGIN */
+  PropertyDetails d = it.property_details();
+/* MODIFIED CODE END */
   details->set(1, d.AsSmi());
   details->set(
       2, isolate->heap()->ToBoolean(it.state() == LookupIterator::INTERCEPTOR));
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/lib/internal/bootstrap_node.js a/examples/pxScene2d/external/libnode-v6.9.0/lib/internal/bootstrap_node.js
index fc3121b..6f6b7a7 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/lib/internal/bootstrap_node.js
+++ a/examples/pxScene2d/external/libnode-v6.9.0/lib/internal/bootstrap_node.js
@@ -150,7 +150,9 @@
       } else {
         preloadModules();
         // If -i or --interactive were passed, or stdin is a TTY.
-        if (process._forceRepl || NativeModule.require('tty').isatty(0)) {
+/* MODIFIED CODE BEGIN */
+//        if (process._debugWaitConnect || process._forceRepl || NativeModule.require('tty').isatty(0)) {
+/* MODIFIED CODE END */
           // REPL
           const cliRepl = NativeModule.require('internal/repl');
           cliRepl.createInternalRepl(process.env, function(err, repl) {
@@ -172,6 +174,8 @@
             // User passed '-e' or '--eval'
             evalScript('[eval]');
           }
+/* MODIFIED CODE BEGIN */
+/*
         } else {
           // Read all of stdin - execute it.
           process.stdin.setEncoding('utf8');
@@ -185,7 +189,8 @@
             process._eval = code;
             evalScript('[stdin]');
           });
-        }
+        } */
+/* MODIFIED CODE END */
       }
     }
   }
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/lib/net.js a/examples/pxScene2d/external/libnode-v6.9.0/lib/net.js
index 5caf774..abf1b86 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/lib/net.js
+++ a/examples/pxScene2d/external/libnode-v6.9.0/lib/net.js
@@ -9,6 +9,9 @@ const internalNet = require('internal/net');
 const assert = require('assert');
 const cares = process.binding('cares_wrap');
 const uv = process.binding('uv');
+/*MODIFIED CODE BEGIN*/
+const fileSystem = require('fs');
+/*MODIFIED CODE END*/
 
 const Buffer = require('buffer').Buffer;
 const TTYWrap = process.binding('tty_wrap');
@@ -944,6 +947,22 @@ function lookupAndConnect(self, options) {
   var localAddress = options.localAddress;
   var localPort = options.localPort;
 
+/*MODIFIED CODE BEGIN*/
+  var ipMode = 0;
+  try {
+    fileSystem.accessSync('/tmp/ipmode_v4');
+    ipMode = 4;
+  } catch(e) {
+    debug('/tmp/ipmode_v4 does not exist');
+  }
+
+  try {
+    fileSystem.accessSync('/tmp/ipmode_v6');
+    ipMode = 6;
+  } catch(e) {
+    debug('/tmp/ipmode_v6 does not exist');
+  }
+  /*MODIFIED CODE END*/
   if (localAddress && !exports.isIP(localAddress))
     throw new TypeError('"localAddress" option must be a valid IP: ' +
                         localAddress);
@@ -982,6 +1001,11 @@ function lookupAndConnect(self, options) {
     dnsopts.hints = dns.ADDRCONFIG;
   }
 
+/*MODIFIED CODE BEGIN*/
+  if (ipMode == 4 || ipMode == 6) {
+    dnsopts.family = ipMode;
+  }
+/*MODIFIED CODE END*/
   debug('connect: find host ' + host);
   debug('connect: dns options', dnsopts);
   self._host = host;
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/node.gyp a/examples/pxScene2d/external/libnode-v6.9.0/node.gyp
index 4043269..26b81fe 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/node.gyp
+++ a/examples/pxScene2d/external/libnode-v6.9.0/node.gyp
@@ -8,7 +8,7 @@
     'node_no_browser_globals%': 'false',
     'node_use_v8_platform%': 'true',
     'node_use_bundled_v8%': 'true',
-    'node_shared%': 'false',
+    'node_shared%': 'true',
     'force_dynamic_crt%': 0,
     'node_module_version%': '',
     'node_shared_zlib%': 'false',
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/src/node.cc a/examples/pxScene2d/external/libnode-v6.9.0/src/node.cc
index bb3a198..0e45661 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/src/node.cc
+++ a/examples/pxScene2d/external/libnode-v6.9.0/src/node.cc
@@ -141,21 +141,31 @@ static const char* eval_string = nullptr;
 static unsigned int preload_module_count = 0;
 static const char** preload_modules = nullptr;
 #if HAVE_INSPECTOR
-static bool use_inspector = false;
+/* MODIFIED CODE */
+bool use_inspector = false;
 #else
-static const bool use_inspector = false;
+/* MODIFIED CODE */
+const bool use_inspector = false;
 #endif
-static bool use_debug_agent = false;
-static bool debug_wait_connect = false;
+/*MODIFIED CODE BEGIN*/
+//static bool use_debug_agent = false;
+//static bool debug_wait_connect = false;
 static std::string debug_host;  // NOLINT(runtime/string)
-static int debug_port = 5858;
+//static int debug_port = 5858;
+bool use_debug_agent = false;
+bool debug_wait_connect = false;
+int debug_port = 5858;
+/*MODIFIED CODE END*/
 static std::string inspector_host;  // NOLINT(runtime/string)
 static int inspector_port = 9229;
 static const int v8_default_thread_pool_size = 4;
 static int v8_thread_pool_size = v8_default_thread_pool_size;
 static bool prof_process = false;
 static bool v8_is_profiling = false;
-static bool node_is_initialized = false;
+/*MODIFIED CODE BEGIN*/
+//static bool node_is_initialized = false;
+bool node_is_initialized = false;
+/*MODIFIED CODE END*/
 static node_module* modpending;
 static node_module* modlist_builtin;
 static node_module* modlist_linked;
@@ -190,10 +200,17 @@ bool config_preserve_symlinks = false;
 // process-relative uptime base, initialized at start-up
 static double prog_start_time;
 static bool debugger_running;
-static uv_async_t dispatch_debug_messages_async;
+/*MODIFIED CODE BEGIN*/
+//static uv_async_t dispatch_debug_messages_async;
+uv_async_t dispatch_debug_messages_async;
+/*MODIFIED CODE END*/
 
 static Mutex node_isolate_mutex;
-static v8::Isolate* node_isolate;
+/*MODIFIED CODE BEGIN*/
+//static v8::Isolate* node_isolate;
+v8::Isolate* node_isolate;
+FILE* errorFile = NULL;
+/*MODIFIED CODE END*/
 
 static struct {
 #if NODE_USE_V8_PLATFORM
@@ -238,6 +255,28 @@ static uv_sem_t debug_semaphore;
 static const unsigned kMaxSignal = 32;
 #endif
 
+/* MODIFIED CODE BEGIN */
+static void PrintErrorStringToFile(const char* format, ...) {
+  va_list filelog;
+  va_start(filelog, format);
+  const char* val = getenv("NODE_ERROR_FILE");
+  if (val) {
+    errorFile = fopen(val,"w");
+  }
+  else
+  {
+    errorFile = fopen("/tmp/nodeerror.log","w");
+  }
+  if (NULL != errorFile)
+  {
+    vfprintf(errorFile, format, filelog);
+    fclose(errorFile);
+    errorFile = NULL;
+  }
+  va_end(filelog);
+}
+/* MODIFIED CODE END */
+
 static void PrintErrorString(const char* format, ...) {
   va_list ap;
   va_start(ap, format);
@@ -273,7 +312,6 @@ static void PrintErrorString(const char* format, ...) {
   va_end(ap);
 }
 
-
 static void CheckImmediate(uv_check_t* handle) {
   Environment* env = Environment::from_immediate_check_handle(handle);
   HandleScope scope(env->isolate());
@@ -1078,7 +1116,7 @@ static bool DomainsStackHasErrorHandler(const Environment* env) {
 }
 
 
-static bool ShouldAbortOnUncaughtException(Isolate* isolate) {
+/* MODIFIED CODE static*/ bool ShouldAbortOnUncaughtException(Isolate* isolate) {
   HandleScope scope(isolate);
 
   Environment* env = Environment::GetCurrent(isolate);
@@ -1630,6 +1668,9 @@ void AppendExceptionLine(Environment* env,
 
     uv_tty_reset_mode();
     PrintErrorString("\n%s", arrow);
+    /* MODIFIED CODE BEGIN */
+    PrintErrorStringToFile("\n%s", arrow);
+    /* MODIFIED CODE END */
     return;
   }
 
@@ -1669,9 +1710,15 @@ static void ReportException(Environment* env,
   if (trace.length() > 0 && !trace_value->IsUndefined()) {
     if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
       PrintErrorString("%s\n", *trace);
+      /* MODIFIED CODE BEGIN */
+      PrintErrorStringToFile("%s\n", *trace);
+      /* MODIFIED CODE END */
     } else {
       node::Utf8Value arrow_string(env->isolate(), arrow);
       PrintErrorString("%s\n%s\n", *arrow_string, *trace);
+      /* MODIFIED CODE BEGIN */
+      PrintErrorStringToFile("%s\n%s\n", *arrow_string, *trace);
+      /* MODIFIED CODE END */
     }
   } else {
     // this really only happens for RangeErrors, since they're the only
@@ -1695,18 +1742,31 @@ static void ReportException(Environment* env,
 
       PrintErrorString("%s\n", *message ? *message :
                                           "<toString() threw exception>");
+      /* MODIFIED CODE BEGIN */
+      PrintErrorStringToFile("%s\n", *message ? *message :
+                                          "<toString() threw exception>");
+      /* MODIFIED CODE END */
     } else {
       node::Utf8Value name_string(env->isolate(), name);
       node::Utf8Value message_string(env->isolate(), message);
 
       if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
         PrintErrorString("%s: %s\n", *name_string, *message_string);
+        /* MODIFIED CODE BEGIN */
+        PrintErrorStringToFile("%s: %s\n", *name_string, *message_string);
+        /* MODIFIED CODE END */
       } else {
         node::Utf8Value arrow_string(env->isolate(), arrow);
         PrintErrorString("%s\n%s: %s\n",
                          *arrow_string,
                          *name_string,
                          *message_string);
+        /* MODIFIED CODE BEGIN */
+        PrintErrorStringToFile("%s\n%s: %s\n",
+                         *arrow_string,
+                         *name_string,
+                         *message_string);
+        /* MODIFIED CODE END */
       }
     }
   }
@@ -2507,14 +2567,19 @@ static void OnFatalError(const char* location, const char* message) {
     PrintErrorString("FATAL ERROR: %s\n", message);
   }
   fflush(stderr);
-  ABORT();
+  /* MODIFIED CODE BEGIN */
+  //ABORT();
+  /* MODIFIED CODE END */
 }
 
-
-NO_RETURN void FatalError(const char* location, const char* message) {
+/* MODIFIED CODE BEGIN */
+/*NO_RETURN*/ void FatalError(const char* location, const char* message) {
+/* MODIFIED CODE END */
   OnFatalError(location, message);
   // to suppress compiler warning
-  ABORT();
+  /* MODIFIED CODE BEGIN */
+  //ABORT();
+  /* MODIFIED CODE END */
 }
 
 
@@ -2558,14 +2623,15 @@ void FatalException(Isolate* isolate,
       exit_code = 1;
     }
   }
-
   if (exit_code) {
 #if HAVE_INSPECTOR
     if (use_inspector) {
       env->inspector_agent()->FatalException(error, message);
     }
 #endif
-    exit(exit_code);
+    /* MODIFIED CODE BEGIN */
+    //exit(exit_code);
+    /* MODIFIED CODE END */
   }
 }
 
@@ -3859,18 +3925,19 @@ static void ParseArgs(int* argc,
 
 
 // Called from V8 Debug Agent TCP thread.
-static void DispatchMessagesDebugAgentCallback(Environment* env) {
+/*static - MODIFIED CODE*/ void DispatchMessagesDebugAgentCallback(Environment* env) {
   // TODO(indutny): move async handle to environment
   uv_async_send(&dispatch_debug_messages_async);
 }
 
-
-static void StartDebug(Environment* env, const char* path, bool wait) {
+/* MODIFIED CODE BEGIN */ void StartDebug(Environment* env, const char* path, bool wait, v8::Platform* platform) {
   CHECK(!debugger_running);
+#ifdef HAVE_INSPECTOR
   if (use_inspector) {
-    debugger_running = v8_platform.StartInspector(env, path, inspector_port,
-                                                  wait);
-  } else {
+    debugger_running = env->inspector_agent()->Start(platform, path, inspector_port, wait);
+  } else
+#endif
+  {
     env->debugger_agent()->set_dispatch_handler(
           DispatchMessagesDebugAgentCallback);
     debugger_running =
@@ -3883,10 +3950,10 @@ static void StartDebug(Environment* env, const char* path, bool wait) {
     }
   }
 }
-
+/* MODIFIED CODE END */
 
 // Called from the main thread.
-static void EnableDebug(Environment* env) {
+/*static - MODIFIED CODE*/ void EnableDebug(Environment* env) {
   CHECK(debugger_running);
 
   if (use_inspector) {
@@ -3921,7 +3988,7 @@ static void TryStartDebugger() {
 
 
 // Called from the main thread.
-static void DispatchDebugMessagesAsyncCallback(uv_async_t* handle) {
+/*static - MODIFIED CODE*/ void DispatchDebugMessagesAsyncCallback(uv_async_t* handle) {
   Mutex::ScopedLock scoped_lock(node_isolate_mutex);
   if (auto isolate = node_isolate) {
     if (debugger_running == false) {
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/src/node.h a/examples/pxScene2d/external/libnode-v6.9.0/src/node.h
index c744c3e..b49a1c0 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/src/node.h
+++ a/examples/pxScene2d/external/libnode-v6.9.0/src/node.h
@@ -42,6 +42,10 @@
 #include "v8.h"  // NOLINT(build/include_order)
 #include "node_version.h"  // NODE_MODULE_VERSION
 
+/* MODIFIED CODE BEGIN */
+#include "node.h"
+/* MODIFIED CODE END */
+
 #define NODE_MAKE_VERSION(major, minor, patch)                                \
   ((major) * 0x1000 + (minor) * 0x100 + (patch))
 
@@ -179,6 +183,12 @@ typedef intptr_t ssize_t;
 namespace node {
 
 NODE_EXTERN extern bool no_deprecation;
+
+/*MODIFIED CODE BEGIN*/
+NODE_EXTERN extern v8::Isolate* node_isolate;
+NODE_EXTERN extern bool node_is_initialized;
+/*MODIFIED CODE END*/
+
 #if HAVE_OPENSSL && NODE_FIPS_MODE
 NODE_EXTERN extern bool enable_fips_crypto;
 NODE_EXTERN extern bool force_fips_crypto;
@@ -192,6 +202,13 @@ NODE_EXTERN void Init(int* argc,
 
 class Environment;
 
+/*MODIFIED CODE BEGIN*/
+NODE_EXTERN void StartDebug(Environment* env, const char* path,bool wait,v8::Platform* platform = nullptr);
+NODE_EXTERN void EnableDebug(Environment* env);
+NODE_EXTERN v8::Isolate* CreateIsolate();
+NODE_EXTERN bool ShouldAbortOnUncaughtException(v8::Isolate* isolate);
+/*MODIFIED CODE END*/
+
 NODE_EXTERN Environment* CreateEnvironment(v8::Isolate* isolate,
                                            struct uv_loop_s* loop,
                                            v8::Local<v8::Context> context,
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/src/node_contextify.cc a/examples/pxScene2d/external/libnode-v6.9.0/src/node_contextify.cc
index 47d7d61..4f7e261 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/src/node_contextify.cc
+++ a/examples/pxScene2d/external/libnode-v6.9.0/src/node_contextify.cc
@@ -43,6 +43,9 @@ using v8::UnboundScript;
 using v8::Value;
 using v8::WeakCallbackInfo;
 
+/* MODIFIED CODE BEGIN */
+extern bool use_inspector;
+/* MODIFIED CODE END */
 
 class ContextifyContext {
  protected:
@@ -67,6 +70,7 @@ class ContextifyContext {
 
 
   ~ContextifyContext() {
+    context_.ClearWeak();
     context_.Reset();
   }
 
@@ -224,6 +228,12 @@ class ContextifyContext {
     // directly in an Object, we instead hold onto the new context's global
     // object instead (which then has a reference to the context).
     ctx->SetEmbedderData(kSandboxObjectIndex, sandbox_obj);
+/*MODIFIED CODE BEGIN */
+    if (use_inspector)
+    {
+      ctx->SetEmbedderData(0, String::NewFromUtf8(env->isolate(), "1,1,Inspector"));
+    }
+/*MODIFIED CODE END */
     sandbox_obj->SetPrivate(env->context(),
                             env->contextify_global_private_symbol(),
                             ctx->Global());
@@ -458,6 +468,72 @@ class ContextifyContext {
   }
 };
 
+/*MODIFIED CODE BEGIN*/
+void deleteContextifyContext(void *ctx)
+{
+  ContextifyContext* context =  (ContextifyContext*)ctx;
+  if (nullptr != context)
+    delete context;
+}
+
+v8::Handle<Context> makeContext(v8::Isolate *isolate, v8::Handle<Object> sandbox)  // basically MakeContext()  circa line 268
+{
+  if (!isolate)
+  {
+    printf("\nERROR: bad isolate pointer.");
+    return Local<Context>(); // NULL;
+  }
+
+    Environment* env = Environment::GetCurrent(isolate);
+//  HandleScope scope(env->isolate());
+
+  if (!sandbox->IsObject())
+  {
+    env->ThrowTypeError("sandbox argument must be an object.");
+    return Local<Context>(); // NULL;
+  }
+  
+  EscapableHandleScope  scope( isolate );
+
+  // Local<Object> sandbox = args[0].As<Object>();
+
+  Local<String> symbol_name =
+      FIXED_ONE_BYTE_STRING(isolate, "_contextifyPrivate");
+
+  // Don't allow contextifying a sandbox multiple times.
+  Local<v8::Private> private_symbol_name = v8::Private::ForApi(isolate, symbol_name);
+  CHECK(
+      !sandbox->HasPrivate(
+          env->context(),
+          private_symbol_name).FromJust());
+
+  TryCatch try_catch(isolate);
+  ContextifyContext* context = new ContextifyContext(env, sandbox);
+
+  if (try_catch.HasCaught())
+  {
+    try_catch.ReThrow();
+    return Local<Context>(); // NULL;
+  }
+
+  if (context->context().IsEmpty())
+  {
+    return Local<Context>(); // NULL;
+  }
+  
+  Local<External> hidden_context = External::New(isolate, context);
+  sandbox->SetPrivate(
+      env->context(),
+      private_symbol_name,
+      hidden_context);
+
+  Local<Context>  local_context = context->context(); // returns a local context 
+  
+  return scope.Escape( local_context ); 
+}
+
+/*MODIFIED CODE END*/
+
 class ContextifyScript : public BaseObject {
  private:
   Persistent<UnboundScript> script_;
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/src/node_contextify_mods.h a/examples/pxScene2d/external/libnode-v6.9.0/src/node_contextify_mods.h
new file mode 100644
index 0000000..1d4ff20
--- /dev/null
+++ a/examples/pxScene2d/external/libnode-v6.9.0/src/node_contextify_mods.h
@@ -0,0 +1,16 @@
+// This is not part of Node... added to expose needed methods.
+
+#include "v8.h"
+
+/*MODIFIED CODE BEGIN*/
+
+namespace node
+{
+  class Environment;
+ 
+  v8::Handle<v8::Context> makeContext(v8::Isolate *isolate, v8::Handle<v8::Object> sandbox);
+  void deleteContextifyContext(void*);
+}
+ 
+/*MODIFIED CODE END*/
+
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/src/node_http_parser.cc a/examples/pxScene2d/external/libnode-v6.9.0/src/node_http_parser.cc
index f757cd6..52569a8 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/src/node_http_parser.cc
+++ a/examples/pxScene2d/external/libnode-v6.9.0/src/node_http_parser.cc
@@ -420,8 +420,14 @@ class Parser : public AsyncWrap {
 
     Parser* parser;
     ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
-
-    CHECK(parser->current_buffer_.IsEmpty());
+    /* MODIFIED CODE BEGIN */
+    //CHECK(parser->current_buffer_.IsEmpty());
+    if (false == parser->current_buffer_.IsEmpty())
+    {
+      parser->got_exception_ = true;
+      return;
+    }
+    /* MODIFIED CODE END */
     parser->got_exception_ = false;
 
     int rv = http_parser_execute(&(parser->parser_), &settings, nullptr, 0);
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/src/node_internals.h a/examples/pxScene2d/external/libnode-v6.9.0/src/node_internals.h
index 530d251..af254ed 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/src/node_internals.h
+++ a/examples/pxScene2d/external/libnode-v6.9.0/src/node_internals.h
@@ -131,7 +131,9 @@ void AppendExceptionLine(Environment* env,
                          v8::Local<v8::Message> message,
                          enum ErrorHandlingMode mode);
 
-NO_RETURN void FatalError(const char* location, const char* message);
+/* MODIFIED CODE BEGIN */
+/*NO_RETURN*/ void FatalError(const char* location, const char* message);
+/* MODIFIED CODE END */
 
 v8::Local<v8::Value> BuildStatsObject(Environment* env, const uv_stat_t* s);
 
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/src/node_watchdog.cc a/examples/pxScene2d/external/libnode-v6.9.0/src/node_watchdog.cc
index 01b3912..539479b 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/src/node_watchdog.cc
+++ a/examples/pxScene2d/external/libnode-v6.9.0/src/node_watchdog.cc
@@ -249,7 +249,10 @@ bool SigintWatchdogHelper::Stop() {
   CHECK_EQ(0, pthread_join(thread_, nullptr));
   has_running_thread_ = false;
 
-  RegisterSignalHandler(SIGINT, SignalExit, true);
+  /* MODIFIED CODE BEGIN */
+  // To make sure SIGINT signal is not caught by libnode
+  // RegisterSignalHandler(SIGINT, SignalExit, true);
+  /* MODIFIED CODE END */
 #else
   SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, FALSE);
 #endif
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/tools/find_vs2017.py a/examples/pxScene2d/external/libnode-v6.9.0/tools/find_vs2017.py
new file mode 100644
index 0000000..a35215f
--- /dev/null
+++ a/examples/pxScene2d/external/libnode-v6.9.0/tools/find_vs2017.py
@@ -0,0 +1,175 @@
+import re
+import sys
+import os
+from ctypes import *
+
+root_dir = os.path.dirname(__file__)
+sys.path.insert(0, os.path.join(root_dir, 'comtypes'))
+
+from comtypes import IUnknown
+from comtypes import GUID
+from comtypes import COMMETHOD
+from comtypes import BSTR
+from comtypes import DWORD
+from comtypes.safearray import _midlSAFEARRAY
+from comtypes.client import CreateObject
+
+
+""" Find Visual Studio 2017 C/C++ compiler install location """
+
+class ISetupInstance(IUnknown):
+  _iid_ = GUID('{B41463C3-8866-43B5-BC33-2B0676F7F42E}')
+  _methods_  = [
+    COMMETHOD([], HRESULT, 'GetInstanceId',
+              ( ['out'], POINTER(BSTR), 'pbstrInstanceId' ) ),
+    COMMETHOD([], HRESULT, 'GetInstallDate',
+              ( ['out'], POINTER(c_ulonglong), 'pInstallDate') ),
+    COMMETHOD([], HRESULT, 'GetInstallationName',
+              ( ['out'], POINTER(BSTR), 'pInstallationName') ),
+    COMMETHOD([], HRESULT, 'GetInstallationPath',
+              ( ['out'], POINTER(BSTR), 'pInstallationPath') ),
+    COMMETHOD([], HRESULT, 'GetInstallationVersion',
+              ( ['out'], POINTER(BSTR), 'pInstallationVersion') ),
+    COMMETHOD([], HRESULT, 'GetDisplayName',
+              ( ['in'], DWORD, 'lcid' ),
+              ( ['out'], POINTER(BSTR), 'pDisplayName') ),
+    COMMETHOD([], HRESULT, 'GetDescription',
+              ( ['in'], DWORD, 'lcid' ),
+              ( ['out'], POINTER(BSTR), 'pDescription') ),
+    COMMETHOD([], HRESULT, 'ResolvePath',
+              ( ['in'], c_wchar_p, 'pRelativePath' ),
+              ( ['out'], POINTER(BSTR), 'pAbsolutePath') ),
+  ]
+
+class ISetupPackageReference(IUnknown):
+  _iid_ = GUID('{da8d8a16-b2b6-4487-a2f1-594ccccd6bf5}')
+  _methods_ = [
+    COMMETHOD([], HRESULT, 'GetId',
+              ( ['out'], POINTER(BSTR), 'pOut' ) ),
+    COMMETHOD([], HRESULT, 'GetVersion',
+              ( ['out'], POINTER(BSTR), 'pOut' ) ),
+    COMMETHOD([], HRESULT, 'GetChip',
+              ( ['out'], POINTER(BSTR), 'pOut' ) ),
+    COMMETHOD([], HRESULT, 'GetLanguage',
+              ( ['out'], POINTER(BSTR), 'pOut' ) ),
+    COMMETHOD([], HRESULT, 'GetBranch',
+              ( ['out'], POINTER(BSTR), 'pOut' ) ),
+    COMMETHOD([], HRESULT, 'GetType',
+              ( ['out'], POINTER(BSTR), 'pOut' ) ),
+    COMMETHOD([], HRESULT, 'GetUniqueId',
+              ( ['out'], POINTER(BSTR), 'pOut' ) )
+  ]
+
+class ISetupInstance2(ISetupInstance):
+  _iid_ = GUID('{89143C9A-05AF-49B0-B717-72E218A2185C}')
+  _methods_ = [
+    COMMETHOD([], HRESULT, 'GetState',
+              ( ['out'],  POINTER(DWORD), 'pState' ) ),
+    COMMETHOD([], HRESULT, 'GetPackages',
+              ( ['out'], POINTER(_midlSAFEARRAY(POINTER(ISetupPackageReference))), 'ppPackage' ) )
+  ]
+
+class IEnumSetupInstances(IUnknown):
+  _iid_ = GUID('{6380BCFF-41D3-4B2E-8B2E-BF8A6810C848}')
+  _methods_ = [
+    COMMETHOD([], HRESULT, 'Next',
+              ( ['in'], c_ulong, 'celt'),
+              ( ['out'], POINTER(POINTER(ISetupInstance)), 'rgelt' ),
+              ( ['out'], POINTER(c_ulong), 'pceltFetched' ) ),
+    COMMETHOD([], HRESULT, 'Skip',
+              ( ['in'], c_ulong, 'celt' ) ),
+    COMMETHOD([], HRESULT, 'Reset'),
+  ]
+
+class ISetupConfiguration(IUnknown):
+  _iid_ = GUID('{42843719-DB4C-46C2-8E7C-64F1816EFD5B}')
+  _methods_ = [
+    COMMETHOD([], HRESULT, 'EnumInstances',
+              ( ['out'],  POINTER(POINTER(IEnumSetupInstances)), 'ppIESI' ) ),
+    COMMETHOD([], HRESULT, 'GetInstanceForCurrentProcess',
+              ( ['out'],  POINTER(POINTER(ISetupInstance)), 'ppISI' ) ),
+    COMMETHOD([], HRESULT, 'GetInstanceForPath',
+              ( ['in'], c_wchar_p, 'wzPath'),
+              ( ['out'],  POINTER(POINTER(ISetupInstance)), 'ppISI' ) )
+  ]
+
+class ISetupConfiguration2(ISetupConfiguration) :
+  _iid_ = GUID('{26AAB78C-4A60-49D6-AF3B-3C35BC93365D}')
+  _methods_ = [
+    COMMETHOD([], HRESULT, 'EnumAllInstances',
+              ( ['out'],  POINTER(POINTER(IEnumSetupInstances)), 'ppIEnumSetupInstances' ) )
+  ]
+
+
+def GetVS2017CPPBasePath():
+  installs = []
+  iface = CreateObject(GUID('{177F0C4A-1CD3-4DE7-A32C-71DBBB9FA36D}'))
+  setupConfiguration = iface.QueryInterface(ISetupConfiguration2)
+  allInstances = setupConfiguration.EnumAllInstances()
+  while True:
+    result = allInstances.Next(1)
+    instance = result[0]
+    if not instance:
+      break
+    path = instance.GetInstallationPath()
+    version = instance.GetInstallationVersion()
+    instance2 = instance.QueryInterface(ISetupInstance2)
+    packages = instance2.GetPackages()        
+    for package in packages:
+      packageId = package.GetId()
+      if packageId == 'Microsoft.VisualStudio.Component.VC.Tools.x86.x64':
+        installs.append(path)
+  return installs
+
+def GetInstalledVS2017WinSDKs(vs_path):
+  sdks = []
+  has81sdk = False
+  win8preg = re.compile(r"Microsoft.VisualStudio.Component.Windows81SDK")
+  win10preg = re.compile(r"Microsoft.VisualStudio.Component.Windows10SDK.(\d+)")
+  iface = CreateObject(GUID('{177F0C4A-1CD3-4DE7-A32C-71DBBB9FA36D}'))
+  setupConfiguration = iface.QueryInterface(ISetupConfiguration2)
+  allInstances = setupConfiguration.EnumAllInstances()
+  while True:
+    result = allInstances.Next(1)
+    instance = result[0]
+    if not instance:
+      break
+    path = instance.GetInstallationPath()
+    if path != vs_path:
+      continue
+    instance2 = instance.QueryInterface(ISetupInstance2)
+    packages = instance2.GetPackages()        
+    for package in packages:
+      packageId = package.GetId()
+      if win8preg.match(packageId):
+        has81sdk = True
+      else:
+        win10match = win10preg.match(packageId)
+        if win10match:
+          sdks.append('10.0.' + str(win10match.group(1)) + '.0')
+    
+    sdks.sort(reverse = True)
+    if has81sdk:
+      sdks.append('8.1')
+    return sdks
+
+def main():
+  if len(sys.argv) == 1:
+    installs = GetVS2017CPPBasePath()
+    if len(installs) == 0:
+      return
+    for install in installs:
+      sdks = GetInstalledVS2017WinSDKs(install)
+      if len(sdks) > 0:
+        print install
+        return
+    print installs[0]
+  else:
+    sdks = GetInstalledVS2017WinSDKs(sys.argv[1])
+    if len(sdks) > 0:
+      print sdks[0]
+
+if __name__ == '__main__':
+  main()
+
+	
\ No newline at end of file
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/tools/gyp/pylib/gyp/MSVSVersion.py a/examples/pxScene2d/external/libnode-v6.9.0/tools/gyp/pylib/gyp/MSVSVersion.py
index d9bfa68..a948e5d 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/tools/gyp/pylib/gyp/MSVSVersion.py
+++ a/examples/pxScene2d/external/libnode-v6.9.0/tools/gyp/pylib/gyp/MSVSVersion.py
@@ -84,6 +84,8 @@ class VisualStudioVersion(object):
       # vcvars32, which it can only find if VS??COMNTOOLS is set, which it
       # isn't always.
       if target_arch == 'x86':
+        if self.short_name == '2017':
+          return [os.path.normpath(ps.path.join(self.path, 'Common7/Tools/VsDevCmd.bat')), '/no_logo','/arch=x86']
         if self.short_name >= '2013' and self.short_name[-1] != 'e' and (
             os.environ.get('PROCESSOR_ARCHITECTURE') == 'AMD64' or
             os.environ.get('PROCESSOR_ARCHITEW6432') == 'AMD64'):
@@ -96,6 +98,9 @@ class VisualStudioVersion(object):
           os.path.join(self.path, 'Common7/Tools/vsvars32.bat'))]
       else:
         assert target_arch == 'x64'
+        if self.short_name == '2017':
+          return [os.path.normpath(
+            ps.path.join(self.path, 'Common7/Tools/VsDevCmd.bat')), '/no_logo', '/arch=x64']
         arg = 'x86_amd64'
         # Use the 64-on-64 compiler if we're not using an express
         # edition and we're running on a 64bit OS.
@@ -226,6 +231,15 @@ def _CreateVersion(name, path, sdk_based=False):
   if path:
     path = os.path.normpath(path)
   versions = {
+      '2017': VisualStudioVersion('2017',
+                                  'Visual Studio 2017',
+                                  solution_version='12.00',
+                                  project_version='14.0',
+                                  flat_sln=False,
+                                  uses_vcxproj=True,
+                                  path=path,
+                                  sdk_based=sdk_based,
+                                  default_toolset='v141'),
       '2015': VisualStudioVersion('2015',
                                   'Visual Studio 2015',
                                   solution_version='12.00',
@@ -346,6 +360,7 @@ def _DetectVisualStudioVersions(versions_to_check, force_express):
       2012(e) - Visual Studio 2012 (11)
       2013(e) - Visual Studio 2013 (12)
       2015    - Visual Studio 2015 (14)
+	  2017    - Visual Studio 2017 (15) 
     Where (e) is e for express editions of MSVS and blank otherwise.
   """
   version_to_year = {
@@ -355,6 +370,7 @@ def _DetectVisualStudioVersions(versions_to_check, force_express):
       '11.0': '2012',
       '12.0': '2013',
       '14.0': '2015',
+	  '15.0': '2017' 
   }
   versions = []
   for version in versions_to_check:
@@ -394,7 +410,17 @@ def _DetectVisualStudioVersions(versions_to_check, force_express):
       if version != '14.0':  # There is no Express edition for 2015.
         versions.append(_CreateVersion(version_to_year[version] + 'e',
             os.path.join(path, '..'), sdk_based=True))
-
+  
+    if version == '15.0':
+      # The VC++ 2017 install location needs to be located using COM instead of
+      # the registry. For details see:
+      # https://blogs.msdn.microsoft.com/heaths/2016/09/15/changes-to-visual-studio-15-setup/
+      # For now we use a hardcoded default with an environment variable
+      # override.
+      path = r'C:\Program Files (x86)\Microsoft Visual Studio\2017\Community'
+      path = os.environ.get('vs2017_install', path)
+      if os.path.exists(path):
+        versions.append(_CreateVersion('2017', path))
   return versions
 
 
@@ -410,7 +436,7 @@ def SelectVisualStudioVersion(version='auto', allow_fallback=True):
   if version == 'auto':
     version = os.environ.get('GYP_MSVS_VERSION', 'auto')
   version_map = {
-    'auto': ('14.0', '12.0', '10.0', '9.0', '8.0', '11.0'),
+    'auto': ('15.0','14.0', '12.0', '10.0', '9.0', '8.0', '11.0'),
     '2005': ('8.0',),
     '2005e': ('8.0',),
     '2008': ('9.0',),
@@ -422,6 +448,7 @@ def SelectVisualStudioVersion(version='auto', allow_fallback=True):
     '2013': ('12.0',),
     '2013e': ('12.0',),
     '2015': ('14.0',),
+	'2017': ('15.0',), 
   }
   override_path = os.environ.get('GYP_MSVS_OVERRIDE_PATH')
   if override_path:
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/tools/gyp/pylib/gyp/generator/msvs.py a/examples/pxScene2d/external/libnode-v6.9.0/tools/gyp/pylib/gyp/generator/msvs.py
index 44cc130..bf906d2 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/tools/gyp/pylib/gyp/generator/msvs.py
+++ a/examples/pxScene2d/external/libnode-v6.9.0/tools/gyp/pylib/gyp/generator/msvs.py
@@ -2622,7 +2622,7 @@ def _GetMSBuildProjectConfigurations(configurations):
   return [group]
 
 
-def _GetMSBuildGlobalProperties(spec, guid, gyp_file_name):
+def _GetMSBuildGlobalProperties(spec, version, guid, gyp_file_name):
   namespace = os.path.splitext(gyp_file_name)[0]
   properties = [
       ['PropertyGroup', {'Label': 'Globals'},
@@ -2661,7 +2661,14 @@ def _GetMSBuildGlobalProperties(spec, guid, gyp_file_name):
       properties[0].append(['ApplicationType', 'Windows Phone'])
     else:
       properties[0].append(['ApplicationType', 'Windows Store'])
-
+  msvs_windows_sdk_version = None
+  if msvs_windows_sdk_version == None and version.ShortName() == '2017':
+    vs2017_sdk = '10.0.16299.0'
+    vs2017_sdk = os.environ.get('vs2017_sdk', vs2017_sdk)
+    if vs2017_sdk:
+      msvs_windows_sdk_version = vs2017_sdk
+  if msvs_windows_sdk_version:
+    properties[0].append(['WindowsTargetPlatformVersion', str(msvs_windows_sdk_version)])
   return properties
 
 def _GetMSBuildConfigurationDetails(spec, build_file):
@@ -3295,7 +3302,7 @@ def _GenerateMSBuildProject(project, options, version, generator_flags):
       }]
 
   content += _GetMSBuildProjectConfigurations(configurations)
-  content += _GetMSBuildGlobalProperties(spec, project.guid, project_file_name)
+  content += _GetMSBuildGlobalProperties(spec, version, project.guid, project_file_name)
   content += import_default_section
   content += _GetMSBuildConfigurationDetails(spec, project.build_file)
   if spec.get('msvs_enable_winphone'):
diff --git b/examples/pxScene2d/external/libnode-v6.9.0/vcbuild.bat a/examples/pxScene2d/external/libnode-v6.9.0/vcbuild.bat
index 4f8a596..adcf5a6 100644
--- b/examples/pxScene2d/external/libnode-v6.9.0/vcbuild.bat
+++ a/examples/pxScene2d/external/libnode-v6.9.0/vcbuild.bat
@@ -1,6 +1,7 @@
 @echo off
 
 cd %~dp0
+set "VSCMD_START_DIR=%CD%"
 
 if /i "%1"=="help" goto help
 if /i "%1"=="--help" goto help
@@ -49,6 +50,7 @@ if /i "%1"=="ia32"          set target_arch=x86&goto arg-ok
 if /i "%1"=="x86"           set target_arch=x86&goto arg-ok
 if /i "%1"=="x64"           set target_arch=x64&goto arg-ok
 if /i "%1"=="vc2015"        set target_env=vc2015&goto arg-ok
+if /i "%1"=="vc2017"        set target_env=vc2017&goto arg-ok 
 if /i "%1"=="noprojgen"     set noprojgen=1&goto arg-ok
 if /i "%1"=="nobuild"       set nobuild=1&goto arg-ok
 if /i "%1"=="nosign"        set nosign=1&goto arg-ok
@@ -133,7 +135,30 @@ if defined noprojgen if defined nobuild if defined nosign if not defined msi got
 
 @rem Set environment for msbuild
 
+@rem Look for Visual Studio 2017
+:vc-set-2017
+if defined target_env if "%target_env%" NEQ "vc2017" goto vc-set-2015
+echo Looking for Visual Studio 2017
+for /f "delims=" %%i in ('python "%~dp0tools\find_vs2017.py"') do set VS2017_INSTALL=%%i
+if not exist "%VS2017_INSTALL%\Common7\Tools\VsDevCmd.bat" goto vc-set-2015
+for /f "delims=" %%i in ('python "%~dp0tools\find_vs2017.py" "%VS2017_INSTALL%"') do set VS2017_SDK=%%i
+echo Found Visual Studio 2017
+if defined msi (
+  echo Cannot build the MSI with Visual Studio 2017 - it is not yet supported by WiX
+  goto vc-set-2015
+)
+if "%VCVARS_VER%" NEQ "150" (
+  call "%VS2017_INSTALL%\Common7\Tools\VsDevCmd.bat" /no_logo
+  set VCVARS_VER=150
+)
+set GYP_MSVS_VERSION=2017
+set PLATFORM_TOOLSET=v141
+goto msbuild-found
+
+
 @rem Look for Visual Studio 2015
+:vc-set-2015
+if defined target_env if "%target_env%" NEQ "vc2015" goto msbuild-not-found
 echo Looking for Visual Studio 2015
 if not defined VS140COMNTOOLS goto msbuild-not-found
 if not exist "%VS140COMNTOOLS%\..\..\vc\vcvarsall.bat" goto msbuild-not-found
@@ -363,7 +388,7 @@ echo Failed to create vc project files.
 goto exit
 
 :help
-echo vcbuild.bat [debug/release] [msi] [test-all/test-uv/test-inspector/test-internet/test-pummel/test-simple/test-message] [clean] [noprojgen] [small-icu/full-icu/without-intl] [nobuild] [nosign] [x86/x64] [vc2015] [download-all] [enable-vtune]
+echo vcbuild.bat [debug/release] [msi] [test-all/test-uv/test-inspector/test-internet/test-pummel/test-simple/test-message] [clean] [noprojgen] [small-icu/full-icu/without-intl] [nobuild] [nosign] [x86/x64] [vc2015/vc2017] [download-all] [enable-vtune]
 echo Examples:
 echo   vcbuild.bat                : builds release build
 echo   vcbuild.bat debug          : builds debug build
