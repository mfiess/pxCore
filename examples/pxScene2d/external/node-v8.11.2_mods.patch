diff --git a/examples/pxScene2d/external/libnode-v8.11.2/deps/v8/src/isolate.cc b/examples/pxScene2d/external/libnode-v8.11.2/deps/v8/src/isolate.cc
index 96f5d65..99e05d2 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/deps/v8/src/isolate.cc
+++ b/examples/pxScene2d/external/libnode-v8.11.2/deps/v8/src/isolate.cc
@@ -1067,6 +1067,14 @@ Object* Isolate::Throw(Object* exception, MessageLocation* location) {
   HandleScope scope(this);
   Handle<Object> exception_handle(exception, this);
 
+  /* MODIFIED CODE BEGIN */
+  char const* stack_on_exception_enabled = getenv("DUMP_STACK_ON_EXCEPTION");
+  if (stack_on_exception_enabled && (strcmp(stack_on_exception_enabled,"1") == 0))
+  {
+    PrintCurrentStackTrace(stderr);
+  }
+  /* MODIFIED CODE END */
+
   if (FLAG_print_all_exceptions) {
     printf("=========================================================\n");
     printf("Exception thrown:\n");
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/lib/internal/bootstrap_node.js b/examples/pxScene2d/external/libnode-v8.11.2/lib/internal/bootstrap_node.js
index 6b7ac04..2ef3924 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/lib/internal/bootstrap_node.js
+++ b/examples/pxScene2d/external/libnode-v8.11.2/lib/internal/bootstrap_node.js
@@ -198,7 +198,9 @@
         perf.markMilestone(
           NODE_PERFORMANCE_MILESTONE_PRELOAD_MODULE_LOAD_END);
         // If -i or --interactive were passed, or stdin is a TTY.
-        if (process._forceRepl || NativeModule.require('tty').isatty(0)) {
+/* MODIFIED CODE BEGIN */
+//        if (process._forceRepl || NativeModule.require('tty').isatty(0)) {
+/* MODIFIED CODE END */
           // REPL
           const cliRepl = NativeModule.require('internal/repl');
           cliRepl.createInternalRepl(process.env, function(err, repl) {
@@ -220,6 +222,8 @@
             // User passed '-e' or '--eval'
             evalScript('[eval]');
           }
+/* MODIFIED CODE BEGIN */
+/*
         } else {
           // Read all of stdin - execute it.
           process.stdin.setEncoding('utf8');
@@ -237,7 +241,8 @@
               evalScript('[stdin]');
             }
           });
-        }
+        } */
+/* MODIFIED CODE END */
       }
     }
     perf.markMilestone(NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/lib/net.js b/examples/pxScene2d/external/libnode-v8.11.2/lib/net.js
index 53c91a6..9abbb20 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/lib/net.js
+++ b/examples/pxScene2d/external/libnode-v8.11.2/lib/net.js
@@ -30,6 +30,9 @@ const { isLegalPort, normalizedArgsSymbol } = require('internal/net');
 const assert = require('assert');
 const cares = process.binding('cares_wrap');
 const uv = process.binding('uv');
+/*MODIFIED CODE BEGIN*/
+const fileSystem = require('fs');
+/*MODIFIED CODE END*/
 
 const { Buffer } = require('buffer');
 const TTYWrap = process.binding('tty_wrap');
@@ -1079,6 +1082,27 @@ function lookupAndConnect(self, options) {
     dnsopts.hints = dns.ADDRCONFIG;
   }
 
+/*MODIFIED CODE BEGIN*/
+  var ipMode = 0;
+  try {
+    fileSystem.accessSync('/tmp/ipmode_v4');
+    ipMode = 4;
+  } catch(e) {
+    debug('/tmp/ipmode_v4 does not exist');
+  }
+
+  try {
+    fileSystem.accessSync('/tmp/ipmode_v6');
+    ipMode = 6;
+  } catch(e) {
+    debug('/tmp/ipmode_v6 does not exist');
+  }
+
+  if (ipMode == 4 || ipMode == 6) {
+    dnsopts.family = ipMode;
+  }
+/*MODIFIED CODE END*/
+
   debug('connect: find host', host);
   debug('connect: dns options', dnsopts);
   self._host = host;
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/src/node.cc b/examples/pxScene2d/external/libnode-v8.11.2/src/node.cc
index 67c8a80..9d4b3dd 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/src/node.cc
+++ b/examples/pxScene2d/external/libnode-v8.11.2/src/node.cc
@@ -184,7 +184,10 @@ static const int v8_default_thread_pool_size = 4;
 static int v8_thread_pool_size = v8_default_thread_pool_size;
 static bool prof_process = false;
 static bool v8_is_profiling = false;
-static bool node_is_initialized = false;
+/*MODIFIED CODE BEGIN*/
+//static bool node_is_initialized = false;
+bool node_is_initialized = false;
+/*MODIFIED CODE END*/
 static node_module* modpending;
 static node_module* modlist_builtin;
 static node_module* modlist_internal;
@@ -265,7 +268,11 @@ bool linux_at_secure = false;
 static double prog_start_time;
 
 static Mutex node_isolate_mutex;
-static v8::Isolate* node_isolate;
+/*MODIFIED CODE BEGIN*/
+//static v8::Isolate* node_isolate;
+v8::Isolate* node_isolate;
+FILE* errorFile = NULL;
+/*MODIFIED CODE END*/
 
 node::DebugOptions debug_options;
 
@@ -351,6 +358,28 @@ static struct {
 static const unsigned kMaxSignal = 32;
 #endif
 
+/* MODIFIED CODE BEGIN */
+static void PrintErrorStringToFile(const char* format, ...) {
+  va_list filelog;
+  va_start(filelog, format);
+  const char* val = getenv("NODE_ERROR_FILE");
+  if (val) {
+    errorFile = fopen(val,"w");
+  }
+  else
+  {
+    errorFile = fopen("/tmp/nodeerror.log","w");
+  }
+  if (NULL != errorFile)
+  {
+    vfprintf(errorFile, format, filelog);
+    fclose(errorFile);
+    errorFile = NULL;
+  }
+  va_end(filelog);
+}
+/* MODIFIED CODE END */
+
 static void PrintErrorString(const char* format, ...) {
   va_list ap;
   va_start(ap, format);
@@ -1838,6 +1867,9 @@ void AppendExceptionLine(Environment* env,
 
     uv_tty_reset_mode();
     PrintErrorString("\n%s", arrow);
+    /* MODIFIED CODE BEGIN */
+    PrintErrorStringToFile("\n%s", arrow);
+    /* MODIFIED CODE END */
     return;
   }
 
@@ -1877,9 +1909,15 @@ static void ReportException(Environment* env,
   if (trace.length() > 0 && !trace_value->IsUndefined()) {
     if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
       PrintErrorString("%s\n", *trace);
+      /* MODIFIED CODE BEGIN */
+      PrintErrorStringToFile("%s\n", *trace);
+      /* MODIFIED CODE END */
     } else {
       node::Utf8Value arrow_string(env->isolate(), arrow);
       PrintErrorString("%s\n%s\n", *arrow_string, *trace);
+      /* MODIFIED CODE BEGIN */
+      PrintErrorStringToFile("%s\n%s\n", *arrow_string, *trace);
+      /* MODIFIED CODE END */
     }
   } else {
     // this really only happens for RangeErrors, since they're the only
@@ -1903,18 +1941,31 @@ static void ReportException(Environment* env,
 
       PrintErrorString("%s\n", *message ? *message :
                                           "<toString() threw exception>");
+      /* MODIFIED CODE BEGIN */
+      PrintErrorStringToFile("%s\n", *message ? *message :
+                                          "<toString() threw exception>");
+      /* MODIFIED CODE END */
     } else {
       node::Utf8Value name_string(env->isolate(), name);
       node::Utf8Value message_string(env->isolate(), message);
 
       if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
         PrintErrorString("%s: %s\n", *name_string, *message_string);
+        /* MODIFIED CODE BEGIN */
+        PrintErrorStringToFile("%s: %s\n", *name_string, *message_string);
+        /* MODIFIED CODE END */
       } else {
         node::Utf8Value arrow_string(env->isolate(), arrow);
         PrintErrorString("%s\n%s: %s\n",
                          *arrow_string,
                          *name_string,
                          *message_string);
+        /* MODIFIED CODE BEGIN */
+        PrintErrorStringToFile("%s\n%s: %s\n",
+                         *arrow_string,
+                         *name_string,
+                         *message_string);
+        /* MODIFIED CODE END */
       }
     }
   }
@@ -2722,14 +2773,20 @@ static void OnFatalError(const char* location, const char* message) {
     PrintErrorString("FATAL ERROR: %s\n", message);
   }
   fflush(stderr);
-  ABORT();
+  /* MODIFIED CODE BEGIN */
+  //ABORT();
+  /* MODIFIED CODE END */
 }
 
 
-NO_RETURN void FatalError(const char* location, const char* message) {
+/* MODIFIED CODE BEGIN */
+/*NO_RETURN*/ void FatalError(const char* location, const char* message) {
+/* MODIFIED CODE END */
   OnFatalError(location, message);
   // to suppress compiler warning
-  ABORT();
+  /* MODIFIED CODE BEGIN */
+  //ABORT();
+  /* MODIFIED CODE END */
 }
 
 
@@ -2778,7 +2835,9 @@ void FatalException(Isolate* isolate,
 #if HAVE_INSPECTOR
     env->inspector_agent()->FatalException(error, message);
 #endif
-    exit(exit_code);
+    /* MODIFIED CODE BEGIN */
+    //exit(exit_code);
+    /* MODIFIED CODE END */
   }
 }
 
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/src/node.h b/examples/pxScene2d/external/libnode-v8.11.2/src/node.h
index 78b2b2b..ebc5f80 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/src/node.h
+++ b/examples/pxScene2d/external/libnode-v8.11.2/src/node.h
@@ -191,6 +191,12 @@ typedef intptr_t ssize_t;
 namespace node {
 
 NODE_EXTERN extern bool no_deprecation;
+
+/*MODIFIED CODE BEGIN*/
+NODE_EXTERN extern v8::Isolate* node_isolate;
+NODE_EXTERN extern bool node_is_initialized;
+/*MODIFIED CODE END*/
+
 #if HAVE_OPENSSL
 NODE_EXTERN extern bool ssl_openssl_cert_store;
 # if NODE_FIPS_MODE
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/src/node_contextify.cc b/examples/pxScene2d/external/libnode-v8.11.2/src/node_contextify.cc
index 47857e8..52e3a4b 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/src/node_contextify.cc
+++ b/examples/pxScene2d/external/libnode-v8.11.2/src/node_contextify.cc
@@ -87,6 +87,7 @@ class ContextifyContext {
 
 
   ~ContextifyContext() {
+    context_.ClearWeak();
     context_.Reset();
   }
 
@@ -1085,4 +1086,74 @@ void InitContextify(Local<Object> target,
 }  // anonymous namespace
 }  // namespace node
 
+/*MODIFIED CODE BEGIN*/
+namespace node
+{
+
+void deleteContextifyContext(void *ctx)
+{
+  ContextifyContext* context =  (ContextifyContext*)ctx;
+  if (nullptr != context)
+    delete context;
+}
+
+v8::Handle<Context> makeContext(v8::Isolate *isolate, v8::Handle<Object> sandbox)  // basically MakeContext()  circa line 268
+{
+  if (!isolate)
+  {
+    printf("\nERROR: bad isolate pointer.");
+    return Local<Context>(); // NULL;
+  }
+
+    Environment* env = Environment::GetCurrent(isolate);
+//  HandleScope scope(env->isolate());
+
+  if (!sandbox->IsObject())
+  {
+    env->ThrowTypeError("sandbox argument must be an object.");
+    return Local<Context>(); // NULL;
+  }
+
+  EscapableHandleScope  scope( isolate );
+
+  // Local<Object> sandbox = args[0].As<Object>();
+
+  Local<String> symbol_name =
+      FIXED_ONE_BYTE_STRING(isolate, "_contextifyPrivate");
+
+  // Don't allow contextifying a sandbox multiple times.
+  Local<v8::Private> private_symbol_name = v8::Private::ForApi(isolate, symbol_name);
+  CHECK(
+      !sandbox->HasPrivate(
+          env->context(),
+          private_symbol_name).FromJust());
+
+  TryCatch try_catch(isolate);
+  ContextifyContext* context = new ContextifyContext(env, sandbox);
+
+  if (try_catch.HasCaught())
+  {
+    try_catch.ReThrow();
+    return Local<Context>(); // NULL;
+  }
+
+  if (context->context().IsEmpty())
+  {
+    return Local<Context>(); // NULL;
+  }
+
+  Local<External> hidden_context = External::New(isolate, context);
+  sandbox->SetPrivate(
+      env->context(),
+      private_symbol_name,
+      hidden_context);
+
+  Local<Context>  local_context = context->context(); // returns a local context
+
+  return scope.Escape( local_context );
+}
+
+} // namespace node
+/*MODIFIED CODE END*/
+
 NODE_BUILTIN_MODULE_CONTEXT_AWARE(contextify, node::InitContextify)
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/src/node_contextify_mods.h b/examples/pxScene2d/external/libnode-v8.11.2/src/node_contextify_mods.h
new file mode 100644
index 0000000..6952bc7
--- /dev/null
+++ b/examples/pxScene2d/external/libnode-v8.11.2/src/node_contextify_mods.h
@@ -0,0 +1,16 @@
+// This is not part of Node... added to expose needed methods.
+
+#include "v8.h"
+
+/*MODIFIED CODE BEGIN*/
+
+namespace node
+{
+  class Environment;
+
+  v8::Handle<v8::Context> makeContext(v8::Isolate *isolate, v8::Handle<v8::Object> sandbox);
+  void deleteContextifyContext(void*);
+}
+
+/*MODIFIED CODE END*/
+
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/src/node_http_parser.cc b/examples/pxScene2d/external/libnode-v8.11.2/src/node_http_parser.cc
index 31dd013..3830f82 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/src/node_http_parser.cc
+++ b/examples/pxScene2d/external/libnode-v8.11.2/src/node_http_parser.cc
@@ -456,7 +456,14 @@ class Parser : public AsyncWrap {
     Parser* parser;
     ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
 
-    CHECK(parser->current_buffer_.IsEmpty());
+    /* MODIFIED CODE BEGIN */
+    //CHECK(parser->current_buffer_.IsEmpty());
+    if (false == parser->current_buffer_.IsEmpty())
+    {
+      parser->got_exception_ = true;
+      return;
+    }
+    /* MODIFIED CODE END */
     parser->got_exception_ = false;
 
     int rv = http_parser_execute(&(parser->parser_), &settings, nullptr, 0);
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/src/node_internals.h b/examples/pxScene2d/external/libnode-v8.11.2/src/node_internals.h
index b2cef8c..0d3ff96 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/src/node_internals.h
+++ b/examples/pxScene2d/external/libnode-v8.11.2/src/node_internals.h
@@ -256,7 +256,9 @@ void AppendExceptionLine(Environment* env,
                          v8::Local<v8::Message> message,
                          enum ErrorHandlingMode mode);
 
-NO_RETURN void FatalError(const char* location, const char* message);
+/* MODIFIED CODE BEGIN */
+/*NO_RETURN*/ void FatalError(const char* location, const char* message);
+/* MODIFIED CODE END */
 
 void ProcessEmitWarning(Environment* env, const char* fmt, ...);
 
diff --git a/examples/pxScene2d/external/libnode-v8.11.2/src/node_watchdog.cc b/examples/pxScene2d/external/libnode-v8.11.2/src/node_watchdog.cc
index af4e9f6..20335ff 100644
--- a/examples/pxScene2d/external/libnode-v8.11.2/src/node_watchdog.cc
+++ b/examples/pxScene2d/external/libnode-v8.11.2/src/node_watchdog.cc
@@ -242,7 +242,10 @@ bool SigintWatchdogHelper::Stop() {
   CHECK_EQ(0, pthread_join(thread_, nullptr));
   has_running_thread_ = false;
 
-  RegisterSignalHandler(SIGINT, SignalExit, true);
+  /* MODIFIED CODE BEGIN */
+  // To make sure SIGINT signal is not caught by libnode
+  // RegisterSignalHandler(SIGINT, SignalExit, true);
+  /* MODIFIED CODE END */
 #else
   watchdog_disabled_ = true;
 #endif
